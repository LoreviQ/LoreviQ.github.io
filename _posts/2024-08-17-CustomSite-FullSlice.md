---
layout: post
title: WebNovelClient - A flexible service for hosting written works
tags: [go, javascript, api, node.js, ci/cd]
comments: false
---

[Github Link](https://github.com/LoreviQ/WebNovelPlatform)

This project is meant to be a comprehensive vertical slice demonstrating a range of my technicaly ability. The idea was to create a platform to share and host written works, since I have a personal interest in writing. An example of the project can be accessed here: https://webnovelclient-y5hewbdc4a-nw.a.run.app/. It is hosted on GCP at the minimum possible level (since it's just for demonstration purposes) so please bear in mind in can sometimes be slow fetching data, this isn't a problem with the code but with the server! Feel free to test making an account and interacting with the site.

## The project demonstrates
  - An API backend made with Go
  - The backend interacting with an SQLite Database hosted by Turso
  - A responsive frontend made with node.js that interacts with the API backend
  - Test Driven Development
  - CI & CD, automatically migrating the production database and deploying latest versions to GCP after testing.

## Backend

### Main

All the code related to my API is in the ./api folder on the github. In main, I create and serve the server, defining endpoints to be handled by my handler functions. A handler function decodes the request, performs an action, and returns a response. For example, the handler function postUser is the following:


    func (cfg *apiConfig) postUser(w http.ResponseWriter, r *http.Request) {
        // REQUEST
        request, err := decodeRequest(w, r, struct {
            Name     string `json:"name"`
            Email    string `json:"email"`
            Password string `json:"password"`
        }{})
        if err != nil {
            respondWithError(w, http.StatusBadRequest, "failed to decode request body")
            return
        }

        // CREATE USER
        hash, err := bcrypt.GenerateFromPassword([]byte(request.Password), 10)
        if err != nil {
            log.Printf("Error generating password hash: %s", err)
            w.WriteHeader(http.StatusInternalServerError)
            return
        }
        user, err := cfg.DB.CreateUser(r.Context(), database.CreateUserParams{
            ID:           uuid.New().String(),
            CreatedAt:    time.Now().UTC().Format(time.RFC3339),
            UpdatedAt:    time.Now().UTC().Format(time.RFC3339),
            Name:         request.Name,
            Email:        request.Email,
            Passwordhash: string(hash),
        })
        if err != nil {
            log.Printf("Error creating user: %s", err)
            respondWithError(w, http.StatusInternalServerError, "Couldn't create user")
            return
        }

        // RESPONSE
        respondWithJSON(w, http.StatusCreated, struct {
            ID        string `json:"id"`
            CreatedAt string `json:"created_at"`
            UpdatedAt string `json:"updated_at"`
            Name      string `json:"name"`
            Email     string `json:"email"`
        }{
            ID:        user.ID,
            CreatedAt: user.CreatedAt,
            UpdatedAt: user.UpdatedAt,
            Name:      user.Name,
            Email:     user.Email,
        })
    }

decodeRequest() and respondWithJSON() are helper functions defined elsewhere which decode the request into a Go struct and respond with a JSON based on a Go Struct respectively. In this cade, the main body of the handler function is responsible for actually creating the user based on the request. For postUser, it generates a hash from the provided password, then creates a database entry with the users data. Other handler functions follow a similar structure. 

### Internal Packages

The api contains two internal package, 'auth' and 'database'. 

'auth' is used for authentication purposes. It has functions that:
  - Authenticate user by comparing passwords to saved password hash
  - Issues Access tokens to users so that they don't need to constantly send passwords (Short duration, non-revocable)
  - Authenticates provided access tokens
  - Issues Refresh tokens to users so that they can obtain more access tokens (Remember me functionality, long duration, revocable)
  - Authenticates provided refresh tokens and issues new access tokens
  - Revoke refresh tokens
  - Manage the generation of unique url-safe ids to be used for UID purposes

'database' is generated by SQLC. Queries are written in SQL in the ./sql/queries directory, and converted into the database package. 

### Testing

I write tests for handlers before writing them, testing the expected functionality of the various endpoints. Tests can be seen in the main package with *_test.go format, using go test. 